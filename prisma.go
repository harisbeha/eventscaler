// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) ScaleEvent(params ScaleEventWhereUniqueInput) *ScaleEventExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ScaleEventWhereUniqueInput!", "ScaleEvent"},
		"scaleEvent",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

type ScaleEventsParams struct {
	Where   *ScaleEventWhereInput   `json:"where,omitempty"`
	OrderBy *ScaleEventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) ScaleEvents(params *ScaleEventsParams) *ScaleEventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ScaleEventWhereInput", "ScaleEventOrderByInput", "ScaleEvent"},
		"scaleEvents",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExecArray{ret}
}

type ScaleEventsConnectionParams struct {
	Where   *ScaleEventWhereInput   `json:"where,omitempty"`
	OrderBy *ScaleEventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) ScaleEventsConnection(params *ScaleEventsConnectionParams) ScaleEventConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "name"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateScaleEvent(params ScaleEventCreateInput) *ScaleEventExec {
	ret := client.Client.Create(
		params,
		[2]string{"ScaleEventCreateInput!", "ScaleEvent"},
		"createScaleEvent",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

type ScaleEventUpdateParams struct {
	Data  ScaleEventUpdateInput      `json:"data"`
	Where ScaleEventWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateScaleEvent(params ScaleEventUpdateParams) *ScaleEventExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ScaleEventUpdateInput!", "ScaleEventWhereUniqueInput!", "ScaleEvent"},
		"updateScaleEvent",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

type ScaleEventUpdateManyParams struct {
	Data  ScaleEventUpdateManyMutationInput `json:"data"`
	Where *ScaleEventWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyScaleEvents(params ScaleEventUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ScaleEventUpdateManyMutationInput!", "ScaleEventWhereInput"},
		"updateManyScaleEvents")
	return &BatchPayloadExec{exec}
}

type ScaleEventUpsertParams struct {
	Where  ScaleEventWhereUniqueInput `json:"where"`
	Create ScaleEventCreateInput      `json:"create"`
	Update ScaleEventUpdateInput      `json:"update"`
}

func (client *Client) UpsertScaleEvent(params ScaleEventUpsertParams) *ScaleEventExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ScaleEventWhereUniqueInput!", "ScaleEventCreateInput!", "ScaleEventUpdateInput!", "ScaleEvent"},
		"upsertScaleEvent",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

func (client *Client) DeleteScaleEvent(params ScaleEventWhereUniqueInput) *ScaleEventExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ScaleEventWhereUniqueInput!", "ScaleEvent"},
		"deleteScaleEvent",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

func (client *Client) DeleteManyScaleEvents(params *ScaleEventWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ScaleEventWhereInput", "deleteManyScaleEvents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type ScaleEventOrderByInput string

const (
	ScaleEventOrderByInputIDAsc            ScaleEventOrderByInput = "id_ASC"
	ScaleEventOrderByInputIDDesc           ScaleEventOrderByInput = "id_DESC"
	ScaleEventOrderByInputStatusAsc        ScaleEventOrderByInput = "status_ASC"
	ScaleEventOrderByInputStatusDesc       ScaleEventOrderByInput = "status_DESC"
	ScaleEventOrderByInputDesiredCountAsc  ScaleEventOrderByInput = "desired_count_ASC"
	ScaleEventOrderByInputDesiredCountDesc ScaleEventOrderByInput = "desired_count_DESC"
	ScaleEventOrderByInputProjectAsc       ScaleEventOrderByInput = "project_ASC"
	ScaleEventOrderByInputProjectDesc      ScaleEventOrderByInput = "project_DESC"
	ScaleEventOrderByInputClusterAsc       ScaleEventOrderByInput = "cluster_ASC"
	ScaleEventOrderByInputClusterDesc      ScaleEventOrderByInput = "cluster_DESC"
	ScaleEventOrderByInputPoolAsc          ScaleEventOrderByInput = "pool_ASC"
	ScaleEventOrderByInputPoolDesc         ScaleEventOrderByInput = "pool_DESC"
	ScaleEventOrderByInputCreatedAtAsc     ScaleEventOrderByInput = "createdAt_ASC"
	ScaleEventOrderByInputCreatedAtDesc    ScaleEventOrderByInput = "createdAt_DESC"
	ScaleEventOrderByInputUpdatedAtAsc     ScaleEventOrderByInput = "updatedAt_ASC"
	ScaleEventOrderByInputUpdatedAtDesc    ScaleEventOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc       UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc      UserOrderByInput = "name_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type ScaleStatus string

const (
	ScaleStatusCreated    ScaleStatus = "CREATED"
	ScaleStatusInProgress ScaleStatus = "IN_PROGRESS"
	ScaleStatusExpired    ScaleStatus = "EXPIRED"
	ScaleStatusFailed     ScaleStatus = "FAILED"
	ScaleStatusRejected   ScaleStatus = "REJECTED"
)

type UserUpdateInput struct {
	Name *string `json:"name,omitempty"`
}

type ScaleEventWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ScaleEventUpdateInput struct {
	Status       *ScaleStatus `json:"status,omitempty"`
	DesiredCount *int32       `json:"desired_count,omitempty"`
	Project      *string      `json:"project,omitempty"`
	Cluster      *string      `json:"cluster,omitempty"`
	Pool         *string      `json:"pool,omitempty"`
}

type ScaleEventWhereInput struct {
	ID                   *string                `json:"id,omitempty"`
	IDNot                *string                `json:"id_not,omitempty"`
	IDIn                 []string               `json:"id_in,omitempty"`
	IDNotIn              []string               `json:"id_not_in,omitempty"`
	IDLt                 *string                `json:"id_lt,omitempty"`
	IDLte                *string                `json:"id_lte,omitempty"`
	IDGt                 *string                `json:"id_gt,omitempty"`
	IDGte                *string                `json:"id_gte,omitempty"`
	IDContains           *string                `json:"id_contains,omitempty"`
	IDNotContains        *string                `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                `json:"id_not_ends_with,omitempty"`
	Status               *ScaleStatus           `json:"status,omitempty"`
	StatusNot            *ScaleStatus           `json:"status_not,omitempty"`
	StatusIn             []ScaleStatus          `json:"status_in,omitempty"`
	StatusNotIn          []ScaleStatus          `json:"status_not_in,omitempty"`
	DesiredCount         *int32                 `json:"desired_count,omitempty"`
	DesiredCountNot      *int32                 `json:"desired_count_not,omitempty"`
	DesiredCountIn       []int32                `json:"desired_count_in,omitempty"`
	DesiredCountNotIn    []int32                `json:"desired_count_not_in,omitempty"`
	DesiredCountLt       *int32                 `json:"desired_count_lt,omitempty"`
	DesiredCountLte      *int32                 `json:"desired_count_lte,omitempty"`
	DesiredCountGt       *int32                 `json:"desired_count_gt,omitempty"`
	DesiredCountGte      *int32                 `json:"desired_count_gte,omitempty"`
	Project              *string                `json:"project,omitempty"`
	ProjectNot           *string                `json:"project_not,omitempty"`
	ProjectIn            []string               `json:"project_in,omitempty"`
	ProjectNotIn         []string               `json:"project_not_in,omitempty"`
	ProjectLt            *string                `json:"project_lt,omitempty"`
	ProjectLte           *string                `json:"project_lte,omitempty"`
	ProjectGt            *string                `json:"project_gt,omitempty"`
	ProjectGte           *string                `json:"project_gte,omitempty"`
	ProjectContains      *string                `json:"project_contains,omitempty"`
	ProjectNotContains   *string                `json:"project_not_contains,omitempty"`
	ProjectStartsWith    *string                `json:"project_starts_with,omitempty"`
	ProjectNotStartsWith *string                `json:"project_not_starts_with,omitempty"`
	ProjectEndsWith      *string                `json:"project_ends_with,omitempty"`
	ProjectNotEndsWith   *string                `json:"project_not_ends_with,omitempty"`
	Cluster              *string                `json:"cluster,omitempty"`
	ClusterNot           *string                `json:"cluster_not,omitempty"`
	ClusterIn            []string               `json:"cluster_in,omitempty"`
	ClusterNotIn         []string               `json:"cluster_not_in,omitempty"`
	ClusterLt            *string                `json:"cluster_lt,omitempty"`
	ClusterLte           *string                `json:"cluster_lte,omitempty"`
	ClusterGt            *string                `json:"cluster_gt,omitempty"`
	ClusterGte           *string                `json:"cluster_gte,omitempty"`
	ClusterContains      *string                `json:"cluster_contains,omitempty"`
	ClusterNotContains   *string                `json:"cluster_not_contains,omitempty"`
	ClusterStartsWith    *string                `json:"cluster_starts_with,omitempty"`
	ClusterNotStartsWith *string                `json:"cluster_not_starts_with,omitempty"`
	ClusterEndsWith      *string                `json:"cluster_ends_with,omitempty"`
	ClusterNotEndsWith   *string                `json:"cluster_not_ends_with,omitempty"`
	Pool                 *string                `json:"pool,omitempty"`
	PoolNot              *string                `json:"pool_not,omitempty"`
	PoolIn               []string               `json:"pool_in,omitempty"`
	PoolNotIn            []string               `json:"pool_not_in,omitempty"`
	PoolLt               *string                `json:"pool_lt,omitempty"`
	PoolLte              *string                `json:"pool_lte,omitempty"`
	PoolGt               *string                `json:"pool_gt,omitempty"`
	PoolGte              *string                `json:"pool_gte,omitempty"`
	PoolContains         *string                `json:"pool_contains,omitempty"`
	PoolNotContains      *string                `json:"pool_not_contains,omitempty"`
	PoolStartsWith       *string                `json:"pool_starts_with,omitempty"`
	PoolNotStartsWith    *string                `json:"pool_not_starts_with,omitempty"`
	PoolEndsWith         *string                `json:"pool_ends_with,omitempty"`
	PoolNotEndsWith      *string                `json:"pool_not_ends_with,omitempty"`
	And                  []ScaleEventWhereInput `json:"AND,omitempty"`
	Or                   []ScaleEventWhereInput `json:"OR,omitempty"`
	Not                  []ScaleEventWhereInput `json:"NOT,omitempty"`
}

type ScaleEventSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *ScaleEventWhereInput              `json:"node,omitempty"`
	And                        []ScaleEventSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ScaleEventSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ScaleEventSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                *string          `json:"id,omitempty"`
	IDNot             *string          `json:"id_not,omitempty"`
	IDIn              []string         `json:"id_in,omitempty"`
	IDNotIn           []string         `json:"id_not_in,omitempty"`
	IDLt              *string          `json:"id_lt,omitempty"`
	IDLte             *string          `json:"id_lte,omitempty"`
	IDGt              *string          `json:"id_gt,omitempty"`
	IDGte             *string          `json:"id_gte,omitempty"`
	IDContains        *string          `json:"id_contains,omitempty"`
	IDNotContains     *string          `json:"id_not_contains,omitempty"`
	IDStartsWith      *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string          `json:"id_not_ends_with,omitempty"`
	Name              *string          `json:"name,omitempty"`
	NameNot           *string          `json:"name_not,omitempty"`
	NameIn            []string         `json:"name_in,omitempty"`
	NameNotIn         []string         `json:"name_not_in,omitempty"`
	NameLt            *string          `json:"name_lt,omitempty"`
	NameLte           *string          `json:"name_lte,omitempty"`
	NameGt            *string          `json:"name_gt,omitempty"`
	NameGte           *string          `json:"name_gte,omitempty"`
	NameContains      *string          `json:"name_contains,omitempty"`
	NameNotContains   *string          `json:"name_not_contains,omitempty"`
	NameStartsWith    *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string          `json:"name_not_ends_with,omitempty"`
	And               []UserWhereInput `json:"AND,omitempty"`
	Or                []UserWhereInput `json:"OR,omitempty"`
	Not               []UserWhereInput `json:"NOT,omitempty"`
}

type ScaleEventCreateInput struct {
	Status       *ScaleStatus `json:"status,omitempty"`
	DesiredCount int32        `json:"desired_count"`
	Project      string       `json:"project"`
	Cluster      string       `json:"cluster"`
	Pool         string       `json:"pool"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type ScaleEventUpdateManyMutationInput struct {
	Status       *ScaleStatus `json:"status,omitempty"`
	DesiredCount *int32       `json:"desired_count,omitempty"`
	Project      *string      `json:"project,omitempty"`
	Cluster      *string      `json:"cluster,omitempty"`
	Pool         *string      `json:"pool,omitempty"`
}

type UserCreateInput struct {
	Name string `json:"name"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ScaleEventConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ScaleEventConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ScaleEventConnectionExec) Edges() *ScaleEventEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScaleEventEdge"},
		"edges",
		[]string{"cursor"})

	return &ScaleEventEdgeExec{ret}
}

func (instance *ScaleEventConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateScaleEvent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ScaleEventConnectionExec) Exec(ctx context.Context) (*ScaleEventConnection, error) {
	var v ScaleEventConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScaleEventConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScaleEventConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ScaleEventConnectionExecArray) Exec(ctx context.Context) ([]ScaleEventConnection, error) {
	var v []ScaleEventConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScaleEventConnection struct {
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type ScaleEventSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ScaleEventSubscriptionPayloadExec) Node() *ScaleEventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScaleEvent"},
		"node",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

func (instance *ScaleEventSubscriptionPayloadExec) PreviousValues() *ScaleEventPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScaleEventPreviousValues"},
		"previousValues",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventPreviousValuesExec{ret}
}

func (instance ScaleEventSubscriptionPayloadExec) Exec(ctx context.Context) (*ScaleEventSubscriptionPayload, error) {
	var v ScaleEventSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScaleEventSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScaleEventSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ScaleEventSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ScaleEventSubscriptionPayload, error) {
	var v []ScaleEventSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScaleEventSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type ScaleEventPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ScaleEventPreviousValuesExec) Exec(ctx context.Context) (*ScaleEventPreviousValues, error) {
	var v ScaleEventPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScaleEventPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScaleEventPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ScaleEventPreviousValuesExecArray) Exec(ctx context.Context) ([]ScaleEventPreviousValues, error) {
	var v []ScaleEventPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScaleEventPreviousValues struct {
	ID           string `json:"id"`
	DesiredCount int32  `json:"desired_count"`
	Project      string `json:"project"`
	Cluster      string `json:"cluster"`
	Pool         string `json:"pool"`
}

type ScaleEventEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ScaleEventEdgeExec) Node() *ScaleEventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScaleEvent"},
		"node",
		[]string{"id", "desired_count", "project", "cluster", "pool"})

	return &ScaleEventExec{ret}
}

func (instance ScaleEventEdgeExec) Exec(ctx context.Context) (*ScaleEventEdge, error) {
	var v ScaleEventEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScaleEventEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScaleEventEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ScaleEventEdgeExecArray) Exec(ctx context.Context) ([]ScaleEventEdge, error) {
	var v []ScaleEventEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScaleEventEdge struct {
	Cursor string `json:"cursor"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ScaleEventExec struct {
	exec *prisma.Exec
}

func (instance ScaleEventExec) Exec(ctx context.Context) (*ScaleEvent, error) {
	var v ScaleEvent
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScaleEventExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScaleEventExecArray struct {
	exec *prisma.Exec
}

func (instance ScaleEventExecArray) Exec(ctx context.Context) ([]ScaleEvent, error) {
	var v []ScaleEvent
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScaleEvent struct {
	ID           string `json:"id"`
	DesiredCount int32  `json:"desired_count"`
	Project      string `json:"project"`
	Cluster      string `json:"cluster"`
	Pool         string `json:"pool"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "name"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}
